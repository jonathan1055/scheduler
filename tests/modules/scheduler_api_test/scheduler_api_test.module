<?php

/**
 * @file
 * Hook implementations of the Scheduler API Test module.
 *
 * Scheduler provides eight hook functions. Each entity type has its own hook
 * function names, to keep them distinct when processing different entity types.
 * Hence this test module has 8 implementations for Nodes and 8 for Media.
 */

use Drupal\node\Entity\Node;
use Drupal\media\Entity\Media;
use Drupal\node\NodeInterface;
use Drupal\media\MediaInterface;

/**
 * Implements hook_scheduler_nid_list().
 */
function scheduler_api_test_scheduler_nid_list($action) {
  $nids = [];
  $request_time = \Drupal::time()->getRequestTime();
  // Check to see what test nodes exist.
  $results = Node::loadMultiple(\Drupal::entityQuery('node')->execute());
  foreach ($results as $nid => $node) {
    // If publishing and this is the publish test node, set a date and add
    // the node id to the list.
    if ($action == 'publish' && $node->title->value == 'API TEST id list publish me') {
      $node->set('publish_on', $request_time)->save();
      $nids[] = $nid;
    }
    // If unpublishing and this is the unpublish test node, set a date and add
    // the node id to the list.
    if ($action == 'unpublish' && $node->title->value == 'API TEST id list unpublish me') {
      $node->set('unpublish_on', $request_time)->save();
      $nids[] = $nid;
    }
  }
  return $nids;
}

/**
 * Implements hook_scheduler_media_list().
 */
function scheduler_api_test_scheduler_media_list($action) {
  $ids = [];
  $request_time = \Drupal::time()->getRequestTime();
  $results = Media::loadMultiple(\Drupal::entityQuery('media')->execute());
  foreach ($results as $mid => $media) {
    // If publishing and this is the publish test media, set a date and add the
    // id to the list.
    if ($action == 'publish' && $media->label() == 'API TEST id list publish me') {
      $media->set('publish_on', $request_time)->save();
      $ids[] = $mid;
    }
    // If unpublishing and this is the unpublish test media, set a date and add
    // the id to the list.
    if ($action == 'unpublish' && $media->label() == 'API TEST id list unpublish me') {
      $media->set('unpublish_on', $request_time)->save();
      $ids[] = $mid;
    }
  }
  return $ids;
}

/**
 * Implements hook_scheduler_nid_list_alter().
 */
function scheduler_api_test_scheduler_nid_list_alter(&$nids, $action) {
  $request_time = \Drupal::time()->getRequestTime();
  $results = Node::loadMultiple(\Drupal::entityQuery('node')->execute());
  foreach ($results as $nid => $node) {
    if ($action == 'publish' && $node->title->value == 'API TEST list_alter do not publish me') {
      // Remove the node id.
      $nids = array_diff($nids, [$nid]);
    }
    if ($action == 'publish' && $node->title->value == 'API TEST list_alter publish me') {
      // Set a publish_on date and add the node id.
      $node->set('publish_on', $request_time)->save();
      $nids[] = $nid;
    }
    if ($action == 'unpublish' && $node->title->value == 'API TEST list_alter do not unpublish me') {
      // Remove the node id.
      $nids = array_diff($nids, [$nid]);
    }
    if ($action == 'unpublish' && $node->title->value == 'API TEST list_alter unpublish me') {
      // Set an unpublish_on date and add the node id.
      $node->set('unpublish_on', $request_time)->save();
      $nids[] = $nid;
    }
  }
}

/**
 * Implements hook_scheduler_media_list_alter().
 */
function scheduler_api_test_scheduler_media_list_alter(&$ids, $action) {
  $request_time = \Drupal::time()->getRequestTime();
  $results = Media::loadMultiple(\Drupal::entityQuery('media')->execute());
  foreach ($results as $mid => $media) {
    if ($action == 'publish' && $media->label() == 'API TEST list_alter do not publish me') {
      // Remove the id.
      $ids = array_diff($ids, [$mid]);
    }
    if ($action == 'publish' && $media->label() == 'API TEST list_alter publish me') {
      // Set a publish_on date and add the id.
      $media->set('publish_on', $request_time)->save();
      $ids[] = $mid;
    }
    if ($action == 'unpublish' && $media->label() == 'API TEST list_alter do not unpublish me') {
      // Remove the id.
      $ids = array_diff($ids, [$mid]);
    }
    if ($action == 'unpublish' && $media->label() == 'API TEST list_alter unpublish me') {
      // Set an unpublish_on date and add the id.
      $media->set('unpublish_on', $request_time)->save();
      $ids[] = $mid;
    }
  }
}

/**
 * Implements hook_scheduler_allow_publishing().
 */
function scheduler_api_test_scheduler_allow_publishing(NodeInterface $node) {
  // If there is no 'Approved for Publishing' field then allow publishing.
  if (!isset($node->field_approved_publishing)) {
    $allowed = TRUE;
  }
  else {
    // Only publish nodes that have 'Approved for Publishing' set.
    $allowed = $node->field_approved_publishing->value;
    // If publication is denied then inform the user why.
    if (!$allowed) {
      \Drupal::messenger()->addMessage(t('%title is scheduled for publishing, but will not be published until approved.', ['%title' => $node->title->value]), 'status', FALSE);
      // If the time is in the past it means that the action has been prevented.
      // Write a dblog message to show this. Give a link to view the node but
      // cater for no nid as the node may be new and not yet saved.
      if ($node->publish_on->value <= \Drupal::time()->getRequestTime()) {
        \Drupal::logger('scheduler_api_test')->warning('Publishing of "%title" is prevented until approved.', [
          '%title' => $node->title->value,
          'link' => $node->id() ? $node->toLink(t('View node'))->toString() : '',
        ]);
      }
    }
  }
  return $allowed;
}

/**
 * Implements hook_scheduler_media_publishing_allowed().
 */
function scheduler_api_test_scheduler_media_publishing_allowed(MediaInterface $media) {
  // If there is no 'Approved for Publishing' field then allow publishing.
  if (!isset($media->field_approved_publishing)) {
    $allowed = TRUE;
  }
  else {
    // Only publish entities that have 'Approved for Publishing' set.
    $allowed = $media->field_approved_publishing->value;
    // If publishing is denied then inform the user why.
    if (!$allowed) {
      // Show a message when the entity is saved.
      \Drupal::messenger()->addMessage(t('%title is scheduled for publishing @publish_time, but will not be published until approved.', [
        '%title' => $media->label(),
        '@publish_time' => \Drupal::service('date.formatter')->format($media->publish_on->value, 'long'),
      ]), 'status', FALSE);
      // If the time is in the past it means that the action has been prevented.
      // Write a dblog message to show this. Give a link to view the entity but
      // cater for no id as the entity may be new and not yet saved.
      if ($media->publish_on->value <= \Drupal::time()->getRequestTime()) {
        \Drupal::logger('scheduler_api_test')->warning('Publishing of "%title" is prevented until approved.', [
          '%title' => $media->label(),
          'link' => !empty($media->id()) ? $media->toLink(t('View media'))->toString() : '',
        ]);
      }
    }
  }
  return $allowed;
}

/**
 * Implements hook_scheduler_allow_unpublishing().
 */
function scheduler_api_test_scheduler_allow_unpublishing(NodeInterface $node) {
  // If there is no 'Approved for Unpublishing' field then allow unpublishing.
  if (!isset($node->field_approved_unpublishing)) {
    $allowed = TRUE;
  }
  else {
    // Only unpublish nodes that have 'Approved for Unpublishing' set.
    $allowed = $node->field_approved_unpublishing->value;
    // If unpublication is denied then inform the user why.
    if (!$allowed) {
      \Drupal::messenger()->addMessage(t('%title is scheduled for unpublishing, but will not be unpublished until approved.', ['%title' => $node->title->value]), 'status', FALSE);
      // If the time is in the past it means that the action has been prevented.
      // Write a dblog message to show this. Give a link to view the node but
      // cater for no nid as the node may be new and not yet saved.
      if ($node->unpublish_on->value <= \Drupal::time()->getRequestTime()) {
        \Drupal::logger('scheduler_api_test')->warning('Unpublishing of "%title" is prevented until approved.', [
          '%title' => $node->title->value,
          'link' => $node->id() ? $node->toLink(t('View node'))->toString() : '',
        ]);
      }
    }
  }
  return $allowed;
}

/**
 * Implements hook_scheduler_media_unpublishing_allowed().
 */
function scheduler_api_test_scheduler_media_unpublishing_allowed(MediaInterface $media) {
  // If there is no 'Approved for Publishing' field then allow publishing.
  if (!isset($media->field_approved_unpublishing)) {
    $allowed = TRUE;
  }
  else {
    // Only unpublish entities that have 'Approved for Unpublishing' set.
    $allowed = $media->field_approved_unpublishing->value;
    // If unpublishing is denied then inform the user why.
    if (!$allowed) {
      // Show a message when the entity is saved.
      \Drupal::messenger()->addMessage(t('%title is scheduled for unpublishing @unpublish_time, but will not be unpublished until approved.', [
        '%title' => $media->label(),
        '@unpublish_time' => \Drupal::service('date.formatter')->format($media->unpublish_on->value, 'long'),
      ]), 'status', FALSE);
      // If the time is in the past it means that the action has been prevented.
      // Write a dblog message to show this. Give a link to view the entity but
      // cater for no id as the entity may be new and not yet saved.
      if ($media->unpublish_on->value <= \Drupal::time()->getRequestTime()) {
        \Drupal::logger('scheduler_api_test')->warning('Unpublishing of "%title" is prevented until approved.', [
          '%title' => $media->label(),
          'link' => !empty($media->id()) ? $media->toLink(t('View media'))->toString() : '',
        ]);
      }
    }
  }
  return $allowed;
}

/**
 * Implements hook_scheduler_hide_publish_date().
 */
function scheduler_api_test_scheduler_hide_publish_date($form, $form_state, $entity) {
  // Hide the publish_on field if the title contains orange.
  if (stristr($entity->label(), 'orange')) {
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: The publish_on field is hidden for orange titles of any entity type.'), 'status', FALSE);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_scheduler_node_hide_publish_date().
 */
function scheduler_api_test_scheduler_node_hide_publish_date($form, $form_state, $node) {
  // Hide the publish_on field if the title contains green node.
  if (stristr($node->title->value, 'green node')) {
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: The publish_on field is hidden for green node titles.'), 'status', FALSE);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_scheduler_media_hide_publish_date().
 */
function scheduler_api_test_scheduler_media_hide_publish_date($form, $form_state, $entity) {
  // Hide the publish_on field if the title contains green media.
  if (stristr($entity->label(), 'green media')) {
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: The publish_on field is hidden for green media titles.'), 'status', FALSE);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_scheduler_hide_unpublish_date().
 */
function scheduler_api_test_scheduler_hide_unpublish_date($form, $form_state, $entity) {
  // Hide the unpublish_on field if the title contains yellow.
  if (stristr($entity->label(), 'yellow')) {
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: The unpublish_on field is hidden for yellow titles of any entity type.'), 'status', FALSE);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_scheduler_node_hide_unpublish_date().
 */
function scheduler_api_test_scheduler_node_hide_unpublish_date($form, $form_state, $node) {
  // Hide the unpublish_on field if the title contains green node.
  if (stristr($node->title->value, 'green node')) {
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: The unpublish_on field is hidden for green node titles.'), 'status', FALSE);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_scheduler_media_hide_unpublish_date().
 */
function scheduler_api_test_scheduler_media_hide_unpublish_date($form, $form_state, $entity) {
  // Hide the unpublish_on field if the title contains green media.
  if (stristr($entity->label(), 'green media')) {
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: The unpublish_on field is hidden for green media titles.'), 'status', FALSE);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_scheduler_publish_process().
 */
function scheduler_api_test_scheduler_publish_process($entity) {
  if (stristr($entity->label(), 'red')) {
    // Any entity with red in the title is simulated to cause a failure and
    // should then be skipped by Scheduler.
    $label_field = $entity->getEntityType()->get('entity_keys')['label'];
    $entity->set($label_field, $entity->label() . ' - publishing failed in API test module');
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: Red entities should cause Scheduler to abandon publishing.'), 'status', FALSE);
    return -1;
  }
  return 0;
}

/**
 * Implements hook_scheduler_node_publish_process().
 */
function scheduler_api_test_scheduler_node_publish_process(NodeInterface $node) {
  if (stristr($node->title->value, 'yellow node')) {
    // Nodes with yellow in the title are simulated to be processed by this
    // hook, and will not be published by Scheduler.
    $node->set('title', $node->title->value . ' - publishing processed by API test module');
    $node->setPublished();
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: Yellow nodes should not have publishing processed by Scheduler.'), 'status', FALSE);
    return 1;
  }
  return 0;
}

/**
 * Implements hook_scheduler_media_publish_process().
 */
function scheduler_api_test_scheduler_media_publish_process(MediaInterface $media) {
  if (stristr($media->label(), 'yellow media')) {
    // Media with yellow in the title are simulated to be processed by this
    // hook, and will not be published by Scheduler.
    $media->set('name', $media->label() . ' - publishing processed by API test module');
    $media->setPublished();
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: Yellow media should not have publishing processed by Scheduler.'), 'status', FALSE);
    return 1;
  }
  return 0;
}

/**
 * Implements hook_scheduler_unpublish_process().
 */
function scheduler_api_test_scheduler_unpublish_process($entity) {
  if (stristr($entity->label(), 'blue')) {
    // Any entity with blue in the title is simulated to cause a failure and
    // should then be skipped by Scheduler.
    $label_field = $entity->getEntityType()->get('entity_keys')['label'];
    $entity->set($label_field, $entity->label() . ' - unpublishing failed in API test module');
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: Blue entities should cause Scheduler to abandon unpublishing.'), 'status', FALSE);
    return -1;
  }
  return 0;
}

/**
 * Implements hook_scheduler_node_unpublish_process().
 */
function scheduler_api_test_scheduler_node_unpublish_process(NodeInterface $node) {
  if (stristr($node->title->value, 'orange node')) {
    // Nodes with orange in the title are simulated to be processed by this
    // hook, and will not be unpublished by Scheduler.
    $node->set('title', $node->title->value . ' - unpublishing processed by API test module');
    $node->setUnpublished();
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: Orange nodes should not have unpublishing processed by Scheduler.'), 'status', FALSE);
    return 1;
  }
  return 0;
}
/**
 * Implements hook_scheduler_media_unpublish_process().
 */
function scheduler_api_test_scheduler_media_unpublish_process(MediaInterface $media) {
  if (stristr($media->label(), 'orange media')) {
    // Media with orange in the title are simulated to be processed by this
    // hook, and will not be unpublished by Scheduler.
    $media->set('name', $media->label() . ' - unpublishing processed by API test module');
    $media->setUnpublished();
    \Drupal::messenger()->addMessage(t('Scheduler_Api_Test: Orange media should not have unpublishing processed by Scheduler.'), 'status', FALSE);
    return 1;
  }
  return 0;
}
