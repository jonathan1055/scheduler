<?php

/**
 * @file
 * Scheduler Rules Integration.
 *
 * This sub-module provides actions, conditions and events for use with the
 * Rules module. All rules code is now moved into this sub-module so that the
 * main Scheduler module does not need Rules as a pre-requisite.
 * @see https://www.drupal.org/node/2790459
 */

use Drupal\Core\Entity\EntityInterface;

/**
 * Implements hook_entity_insert().
 */
function scheduler_rules_integration_entity_insert(EntityInterface $entity) {
  // Invoke the Rules events to indicate that a new entity has been scheduled.
  $scheduler_manager = \Drupal::service('scheduler.manager');
  // If this entity type is is not supported by Scheduler then go further.
  if (!$scheduler_manager->getPlugin($entity->getEntityTypeId())) {
    return;
  }
  // @todo The below blocks could be moved into a function in the plugin, or in
  // Scheduler manager, instead of here. They will be needed many times.
  if (!empty($entity->publish_on->value)) {
    $event_id = 'NEW_FOR_PUBLISHING';
    // Generate fully namespaced class name for RulesNodeEvent, RulesMediaEvent.
    $event_class = '\Drupal\scheduler_rules_integration\Event\Rules'
      . ucfirst($entity->getEntityTypeId()) . 'Event';
    $event = new $event_class($entity);
    $event_name = constant(get_class($event) . "::$event_id");
    $scheduler_manager->dispatch($event, $event_name);
  }
  if (!empty($entity->unpublish_on->value)) {
    $event_id = 'NEW_FOR_UNPUBLISHING';
    // Generate fully namespaced class name for RulesNodeEvent, RulesMediaEvent.
    $event_class = '\Drupal\scheduler_rules_integration\Event\Rules'
      . ucfirst($entity->getEntityTypeId()) . 'Event';
    $event = new $event_class($entity);
    $event_name = constant(get_class($event) . "::$event_id");
    $scheduler_manager->dispatch($event, $event_name);
  }
}

/**
 * Implements hook_entity_update().
 */
function scheduler_rules_integration_entity_update(EntityInterface $entity) {
  $scheduler_manager = \Drupal::service('scheduler.manager');
  // If this entity type is is not supported by Scheduler then go further.
  if (!$scheduler_manager->getPlugin($entity->getEntityTypeId())) {
    return;
  }

  // Invoke Rules events to indicate that an existing entity has been scheduled.
  if (!empty($entity->publish_on->value)) {
    $event_id = 'EXISTING_FOR_PUBLISHING';
    // Generate the fully namespaced class name for the required event, for
    // example RulesNodeEvent or RulesMediaEvent.
    $event_class = '\Drupal\scheduler_rules_integration\Event\Rules'
      . ucfirst($entity->getEntityTypeId()) . 'Event';
    $event = new $event_class($entity);
    $event_name = constant(get_class($event) . "::$event_id");
    $scheduler_manager->dispatch($event, $event_name);
  }

  if (!empty($entity->unpublish_on->value)) {
    $event_id = 'EXISTING_FOR_UNPUBLISHING';
    $event_class = '\Drupal\scheduler_rules_integration\Event\Rules'
      . ucfirst($entity->getEntityTypeId()) . 'Event';
    $event = new $event_class($entity);
    $event_name = constant(get_class($event) . "::$event_id");
    $scheduler_manager->dispatch($event, $event_name);
  }
}

/**
 * Trigger Rules events during cron.
 *
 * This function is called from the main Scheduler module publish() and
 * unpublish() functions in the SchedulerManager class.
 */
function _scheduler_rules_integration_dispatch_cron_event(EntityInterface $entity, $event_type) {
  $scheduler_manager = \Drupal::service('scheduler.manager');

  $event_id = strtoupper("CRON_{$event_type}ED");
  $event_class = '\Drupal\scheduler_rules_integration\Event\Rules'
    . ucfirst($entity->getEntityTypeId()) . 'Event';
  $event = new $event_class($entity);
  $event_name = constant(get_class($event) . "::$event_id");
  $scheduler_manager->dispatch($event, $event_name);
}
